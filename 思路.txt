
//----------------------------------------后台----------------------------------------
1.建议所有的返回提示语句都放在后台接口返回
2.建议后台应预留黑名单权限 限制该账号无法进行主动操作
3.必须 限制后台接口返回的数据类型必须匹配 List类型不能返回null 文档中必须标注字段是否可为空
  建议接口所有的返回值都添加默认值而不是返回null 特别是String类型
  建议接口把不需要的数据都剔除 select * 很简单但是真的很Low Low爆了
4.建议后台添加一条接口可以在接口onError回调中把错误信息返回后台 在测试环境中可以把错误日志放在本地


//----------------------------------------前端----------------------------------------

1.对于本地的存储数据视情况是否需要进行加密存储 比如一些标记数据就不用了
2.一些页面的图片一定要注意使用缓存策略，如果不是常用的图片不要使用内存缓存，
  对于一些大图能不用内存缓存就不用内存缓存，对于本地图片就不需要本地缓存(发布动态，本地选图)


//---------------------------------------- RecyclerView优化 ----------------------------------------

RecyclerView优化 一句话思路 空间换取时间 使用内存空间来换取数据转化的时间
1.在Adapter中最好不要进行任何的逻辑操作，比如日期转换,字符串切割等等,可以在model内部自行添加一个参数使用
  by lazy 来存储数据转换后的结果,这样数据逻辑操作就只执行一次，而不会随着数据回收重复计算
2.新增删除数据不刷线全部，而是刷新局部
3.布局优化，尽量少的布局嵌套，尽量少的控件
4.对于一些RecyclerView嵌套RecyclerView的布局可以进行多布局展示，而不是使用嵌套
5.xml文件的读取,初始化的时候使用 by lazy 生成
6.如果RecyclerView条目高度固定，使用setHasFixedSize(true),避免多次测量条目高度
7.对于RecyclerView，如果不需要动画，就把条目显示动画取消setSupportsChangeAnimations(false)
8.在RecyclerView添加滑动监听，一些图片加载可以在RecyclerView快速滑动的时候不进行加载图片
9.对于一个页面中的多个RecyclerView,如果使用同一个Adapter，可以使用setRecycledViewPool(pool)，共用回收池，
  避免来每一个RecyclerView都创建一个回收池，特别是RecyclerView嵌套RecyclerView时候，
  内部的RecyclerView必定使用的都是同一个Adapter，这个时候就很有必要使用回收池了
10.视情况使用setItemViewCacheSize(size)来加大RecyclerView缓存数目，用空间换取时间提高流畅度
11.对于条目点击时间不要在复用部分进行setOnClickListener，这样会重复设置点击监听，而是应该创建一个listener对象，
   传入控件的id，和当前的条目position，通过id和position判断处理点击监听
12.可以进行预加载,重写LayoutManager的getExtraLayoutSpace()方法,可以返回屏幕高度,预先加载一屏幕高度的数据,
   视情况，例如：一个item就占据一个页面，RecyclerView滑动到第二张，此时第一张可见，RecyclerView无法找到可复用
   的View，此时会重新new一个出来，滑动卡顿，第三张及以后可以找到复用的View，滑动流畅


//---------------------------------------- 异地登陆账号踢出 -------------------------------------


对于项目中的提出弹窗 可以设置一个Dialog形式的Activity，内部逻辑都可以放在Activity中，直接使用application来进行跳转，
注意添加FLAG_ACTIVITY_NEW_TASK，具体展示可以查看KickOutActivity


//---------------------------------------- 对于多种状态显示不同页面 -------------------------------------


强烈建议：增加页面文件来减少逻辑的复杂程度，因为一开始的逻辑都是清晰的，在一段时间过后，逻辑就会因为业务的堆叠不断增加，
导致逻辑越来越复杂，所以需要尽可能的减少逻辑的复杂程度，带来的消耗就是页面的增多，两者权衡之间是可以接受的

例如：对于一个页面部分内容根据某个字段来进行展示不同内容，建议使用多个Fragment来替换，
这样每一个页面的逻辑都可以在各个Fragment中来进行数据设置，使页面的逻辑更加清晰简单，通过增加页面来减少逻辑的复杂程度

